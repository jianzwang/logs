- ## Defining a Trait for Common Behavior
	- The advantage of using trait objects and Rust’s type system to write code similar to code using duck typing is that we never have to check whether a value implements a particular method at runtime or worry about getting errors if a value doesn’t implement a method bu tuse Rust won’t compile our code if the values don’t implement the traits that the trait objects need.
- ## monomorphization process
	- performed by the compiler when we use trait bounds on generics: the compiler generates non generic implementations of functions and methods foreach concrete type that we use in place of a generic type parameter. The code that results from monomorphization is doing _static dispatch_,which is when the compiler knows what method you’re calling at compile time.
		- _dynamic dispatch_,which is whenuse gui::Screen;fnmain() {let screen = Screen {        components: vec![Box::new(String::from("Hi"))],    };    screen.run();}$ cargo run   Compiling gui v0.1.0 (file:///projects/gui)error[E0277]: the trait bound `String: Draw` is not satisfied --> src/main.rs:5:26  |5 |         components: vec![Box::new(String::from("Hi"))],  |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Draw` isnot implemented for `String`  |  = note: required for the cast to the object type `dyn Draw`For more information about this error, try `rustc --explain E0277`.error: could not compile `gui` due to previous error2022/3/17 11:36The Rust Programming Languagehttps://doc.rust-lang.org/book/print.html458/612the compiler can’t tell at compile time which method you’re calling. In dynamic dispatchcases, the compiler emits code that at runtime will figure out which method to call.